{"version":3,"sources":["incremental-dom-closure-provides.js","src/assertions.js","src/notifications.js","src/context.js","src/util.js","src/node_data.js","src/symbols.js","src/attributes.js","src/nodes.js","src/core.js","src/virtual_elements.js"],"names":[],"mappings":"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","file":"incremental-dom-closure-provides.js","sourcesContent":["goog.provide('incremental_dom');\ngoog.scope(function(){\nvar exports = incremental_dom;\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nvar inAttributes = false;\n\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nvar inSkip = false;\n\n\n/**\n * Makes sure that there is a current patch context.\n * @param {*} context\n */\nvar assertInPatch = function(context) {\n  if (!context) {\n    throw new Error('Cannot call currentElement() unless in patch');\n  }\n};\n\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function(nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' +\n        tag + ', not a ' + nodeName + '.');\n  }\n};\n\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nvar assertNoUnclosedTags = function(openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  var currentElement = openElement;\n  var openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' +\n      openTags.join('\\n'));\n};\n\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nvar assertNotInAttributes = function(functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() may not be called between ' +\n        'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nvar assertNotInSkip = function(functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' +\n        'that has called skip().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nvar assertInAttributes = function(functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() must be called after ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nvar assertVirtualAttributesClosed = function() {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n  * Makes sure that placeholders have a key specified. Otherwise, conditional\n  * placeholders and conditional elements next to placeholders will cause\n  * placeholder elements to be re-used as non-placeholders and vice versa.\n  * @param {string} key\n  */\nvar assertPlaceholderKeySpecified = function(key) {\n  if (!key) {\n    throw new Error('Placeholder elements must have a key specified.');\n  }\n};\n\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {string} nodeName\n  * @param {string} tag\n  */\nvar assertCloseMatchesOpenTag = function(nodeName, tag) {\n  if (nodeName !== tag) {\n    throw new Error('Received a call to close ' + tag + ' but ' +\n        nodeName + ' was open.');\n  }\n};\n\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nvar assertNoChildrenDeclaredYet = function(functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' +\n        'declarations inside the current element.');\n  }\n};\n\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInAttributes = function(value) {\n  var previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInSkip = function(value) {\n  var previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** */\nexports.notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = exports.notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = exports.notifications.nodesDeleted && [];\n}\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function(node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function(node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function() {\n  if (this.created && this.created.length > 0) {\n    exports.notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    exports.notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function() {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function(node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function(node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nexports.applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nexports.applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */(style);\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function(el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    exports.applyProp(el, name, value);\n  } else {\n    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function(el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nexports.attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nexports.attributes[exports.symbols.default] = applyAttributeTyped;\n\nexports.attributes[exports.symbols.placeholder] = function() {};\n\nexports.attributes['style'] = applyStyle;\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function(tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function(doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/(statics[i]), statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function(doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function(el) {\n  var map = createMap();\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function(el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function(parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function(parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode;\n\n/** @type {?Node} */\nvar currentParent;\n\n/** @type {?Node} */\nvar previousNode;\n\n/** @type {?Element|?DocumentFragment} */\nvar root;\n\n/** @type {?Document} */\nvar doc;\n\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nexports.patch = function(node, fn, data) {\n  var prevContext = context;\n  var prevRoot = root;\n  var prevDoc = doc;\n  var prevCurrentNode = currentNode;\n  var prevCurrentParent = currentParent;\n  var prevPreviousNode = previousNode;\n  var previousInAttributes = false;\n  var previousInSkip = false;\n\n  context = new Context();\n  root = node;\n  doc = node.ownerDocument;\n  currentNode = node;\n  currentParent = null;\n  previousNode = null;\n\n  if (goog.DEBUG) {\n    previousInAttributes = setInAttributes(false);\n    previousInSkip = setInSkip(false);\n  }\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (goog.DEBUG) {\n    assertVirtualAttributesClosed();\n    assertNoUnclosedTags(previousNode, node);\n    setInAttributes(previousInAttributes);\n    setInSkip(previousInSkip);\n  }\n\n  context.notifyChanges();\n\n  context = prevContext;\n  root = prevRoot;\n  doc = prevDoc;\n  currentNode = prevCurrentNode;\n  currentParent = prevCurrentParent;\n  previousNode = prevPreviousNode;\n};\n\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function(nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function(nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && goog.DEBUG) {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function() {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key;\n\n  if (child === previousNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[exports.symbols.placeholder] && node !== root) {\n    return;\n  }\n\n  while (child !== previousNode) {\n    node.removeChild(child);\n    context.markDeleted(/** @type {!Node}*/(child));\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function() {\n  currentParent = currentNode;\n  currentNode = currentNode.firstChild;\n  previousNode = null;\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function() {\n  previousNode = currentNode;\n  currentNode = currentNode.nextSibling;\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function() {\n  clearUnvisitedDOM();\n\n  previousNode = currentParent;\n  currentNode = currentParent.nextSibling;\n  currentParent = currentParent.parentNode;\n};\n\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar _elementOpen = function(tag, key, statics) {\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar _elementClose = function() {\n  if (goog.DEBUG) {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return /** @type {!Element} */(previousNode);\n};\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar _text = function() {\n  alignWithDOM('#text', null, null);\n  nextNode();\n  return /** @type {!Text} */(previousNode);\n};\n\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nexports.currentElement = function() {\n  if (goog.DEBUG) {\n    assertInPatch(context);\n    assertNotInAttributes('currentElement');\n  }\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nexports.skip = function() {\n  if (goog.DEBUG) {\n    assertNoChildrenDeclaredYet('skip', previousNode);\n    setInSkip(true);\n  }\n  previousNode = currentParent.lastChild;\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpen = function(tag, key, statics, var_args) {\n  if (goog.DEBUG) {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  var node = _elementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n      newAttrs[attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nexports.elementOpenStart = function(tag, key, statics) {\n  if (goog.DEBUG) {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nexports.attr = function(name, value) {\n  if (goog.DEBUG) {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name, value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpenEnd = function() {\n  if (goog.DEBUG) {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  var node = exports.elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nexports.elementClose = function(tag) {\n  if (goog.DEBUG) {\n    assertNotInAttributes('elementClose');\n  }\n\n  var node = _elementClose();\n\n  if (goog.DEBUG) {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementVoid = function(tag, key, statics, var_args) {\n  var node = exports.elementOpen.apply(null, arguments);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementPlaceholder = function(tag, key, statics, var_args) {\n  if (goog.DEBUG) {\n    assertPlaceholderKeySpecified(key);\n  }\n\n  exports.elementOpen.apply(null, arguments);\n  exports.skip();\n  return exports.elementClose.apply(null, arguments);\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nexports.text = function(value, var_args) {\n  if (goog.DEBUG) {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  var node = _text();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\n});","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nvar inAttributes = false;\n\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nvar inSkip = false;\n\n\n/**\n * Makes sure that there is a current patch context.\n * @param {*} context\n */\nvar assertInPatch = function(context) {\n  if (!context) {\n    throw new Error('Cannot call currentElement() unless in patch');\n  }\n};\n\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function(nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' +\n        tag + ', not a ' + nodeName + '.');\n  }\n};\n\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nvar assertNoUnclosedTags = function(openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  var currentElement = openElement;\n  var openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' +\n      openTags.join('\\n'));\n};\n\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nvar assertNotInAttributes = function(functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() may not be called between ' +\n        'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nvar assertNotInSkip = function(functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' +\n        'that has called skip().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nvar assertInAttributes = function(functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() must be called after ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nvar assertVirtualAttributesClosed = function() {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n  * Makes sure that placeholders have a key specified. Otherwise, conditional\n  * placeholders and conditional elements next to placeholders will cause\n  * placeholder elements to be re-used as non-placeholders and vice versa.\n  * @param {string} key\n  */\nvar assertPlaceholderKeySpecified = function(key) {\n  if (!key) {\n    throw new Error('Placeholder elements must have a key specified.');\n  }\n};\n\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {string} nodeName\n  * @param {string} tag\n  */\nvar assertCloseMatchesOpenTag = function(nodeName, tag) {\n  if (nodeName !== tag) {\n    throw new Error('Received a call to close ' + tag + ' but ' +\n        nodeName + ' was open.');\n  }\n};\n\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nvar assertNoChildrenDeclaredYet = function(functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' +\n        'declarations inside the current element.');\n  }\n};\n\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInAttributes = function(value) {\n  var previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInSkip = function(value) {\n  var previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n\n/** */\nexport {\n  assertInPatch,\n  assertKeyedTagMatches,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertInAttributes,\n  assertPlaceholderKeySpecified,\n  assertCloseMatchesOpenTag,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertNotInSkip,\n  setInAttributes,\n  setInSkip\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\nexport {\n  notifications\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { notifications } from './notifications';\n\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function(node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function(node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function() {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n\n/** */\nexport {\n  Context\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function() {\n  return create(null);\n};\n\n\n/** */\nexport {\n  createMap,\n  has\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createMap } from './util';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function(node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function(node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n\n/** */\nexport {\n  getData,\n  initData\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/** */\nexport {\n  symbols\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  createMap,\n  has\n} from './util';\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */(style);\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function(el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function(el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function() {};\n\nattributes['style'] = applyStyle;\n\n\n/** */\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { updateAttribute } from './attributes';\nimport {\n    getData,\n    initData\n} from './node_data';\nimport { createMap } from './util';\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function(tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function(doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/(statics[i]), statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function(doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function(el) {\n  var map = createMap();\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function(el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function(parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function(parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n\n/** */\nexport {\n  createElement,\n  createText,\n  getChild,\n  registerChild\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  createElement,\n  createText,\n  getChild,\n  registerChild\n} from './nodes';\nimport { getData } from './node_data';\nimport { Context } from './context';\nimport { symbols } from './symbols';\nimport {\n  assertInPatch,\n  assertKeyedTagMatches,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  setInAttributes,\n  setInSkip\n} from './assertions';\nimport { notifications } from './notifications';\n\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode;\n\n/** @type {?Node} */\nvar currentParent;\n\n/** @type {?Node} */\nvar previousNode;\n\n/** @type {?Element|?DocumentFragment} */\nvar root;\n\n/** @type {?Document} */\nvar doc;\n\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patch = function(node, fn, data) {\n  var prevContext = context;\n  var prevRoot = root;\n  var prevDoc = doc;\n  var prevCurrentNode = currentNode;\n  var prevCurrentParent = currentParent;\n  var prevPreviousNode = previousNode;\n  var previousInAttributes = false;\n  var previousInSkip = false;\n\n  context = new Context();\n  root = node;\n  doc = node.ownerDocument;\n  currentNode = node;\n  currentParent = null;\n  previousNode = null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    previousInAttributes = setInAttributes(false);\n    previousInSkip = setInSkip(false);\n  }\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertVirtualAttributesClosed();\n    assertNoUnclosedTags(previousNode, node);\n    setInAttributes(previousInAttributes);\n    setInSkip(previousInSkip);\n  }\n\n  context.notifyChanges();\n\n  context = prevContext;\n  root = prevRoot;\n  doc = prevDoc;\n  currentNode = prevCurrentNode;\n  currentParent = prevCurrentParent;\n  previousNode = prevPreviousNode;\n};\n\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function(nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function(nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && process.env.NODE_ENV !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function() {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key;\n\n  if (child === previousNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    return;\n  }\n\n  while (child !== previousNode) {\n    node.removeChild(child);\n    context.markDeleted(/** @type {!Node}*/(child));\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function() {\n  currentParent = currentNode;\n  currentNode = currentNode.firstChild;\n  previousNode = null;\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function() {\n  previousNode = currentNode;\n  currentNode = currentNode.nextSibling;\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function() {\n  clearUnvisitedDOM();\n\n  previousNode = currentParent;\n  currentNode = currentParent.nextSibling;\n  currentParent = currentParent.parentNode;\n};\n\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function(tag, key, statics) {\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return /** @type {!Element} */(previousNode);\n};\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar text = function() {\n  alignWithDOM('#text', null, null);\n  nextNode();\n  return /** @type {!Text} */(previousNode);\n};\n\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch(context);\n    assertNotInAttributes('currentElement');\n  }\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', previousNode);\n    setInSkip(true);\n  }\n  previousNode = currentParent.lastChild;\n};\n\n\n/** */\nexport {\n  elementOpen,\n  elementClose,\n  text,\n  patch,\n  currentElement,\n  skip\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  elementOpen as coreElementOpen,\n  elementClose as coreElementClose,\n  text as coreText,\n  currentElement,\n  skip\n} from './core';\nimport { updateAttribute } from './attributes';\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  assertNotInAttributes,\n  assertNotInSkip,\n  assertInAttributes,\n  assertPlaceholderKeySpecified,\n  assertCloseMatchesOpenTag,\n  setInAttributes\n} from './assertions';\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  var node = coreElementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n      newAttrs[attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function(tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name, value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function(tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  var node = coreElementClose();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function(tag, key, statics, var_args) {\n  var node = elementOpen.apply(null, arguments);\n  elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n  }\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose.apply(null, arguments);\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function(value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  elementPlaceholder,\n  text,\n  attr\n};\n"],"sourceRoot":"/source/"}